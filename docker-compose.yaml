
services:
  # PostgreSQL Database Service
  db:
    image: postgres:16-alpine # Using a lightweight PostgreSQL image
    container_name: postgres_db
    environment:
      POSTGRES_DB: restaurant_db
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432" # Map container port 5432 to host port 5432
    volumes:
      - pgdata:/var/lib/postgresql/data # Persistent volume for database data
    healthcheck: # Health check to ensure DB is ready before app starts
      test: ["CMD-SHELL", "pg_isready -U user -d restaurant_db"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Redis Service
  redis:
    image: redis:7-alpine # Using a lightweight Redis image
    container_name: redis_cache
    ports:
      - "6379:6379" # Map container port 6379 to host port 6379
    volumes:
      - redisdata:/data # Persistent volume for Redis data

  # RabbitMQ Message Broker Service
  rabbitmq:
    image: rabbitmq:3-management-alpine # RabbitMQ with management UI
    container_name: rabbitmq_broker
    ports:
      - "5672:5672" # AMQP protocol port
      - "15672:15672" # Management UI port
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    healthcheck: # Health check for RabbitMQ
      test: ["CMD", "rabbitmq-diagnostics", "check_port_connectivity"]
      interval: 10s
      timeout: 5s
      retries: 5

  # # FastAPI Application Service (Orchestration Order Service)
  # app:
  #   build: . # Build the image from the current directory (where your Python code is)
  #   container_name: orchestration_app
  #   ports:
  #     - "8002:8002" # Orchestration Order Service port
  #     # If you were running Choreography services in separate containers, you'd add their ports too:
  #     # - "8001:8001" # Choreography Order Service
  #     # - "8003:8003" # Choreography Payment Service
  #     # - "8004:8004" # Choreography Kitchen Service
  #     # - "8005:8005" # Choreography Delivery Service
  #   depends_on:
  #     db:
  #       condition: service_healthy # Ensure DB is healthy before starting app
  #     redis:
  #       condition: service_started
  #     rabbitmq:
  #       condition: service_healthy # Ensure RabbitMQ is healthy before starting app
  #   environment:
  #     # Pass database URL to the FastAPI app.
  #     # 'db' is the service name in docker-compose, which resolves to its internal IP.
  #     DATABASE_URL: "postgresql://user:password@db/restaurant_db"
  #     # Redis host will also be 'redis'
  #     REDIS_HOST: "redis"
  #     # RabbitMQ host will also be 'rabbitmq'
  #     RABBITMQ_HOST: "rabbitmq"
  #   command: >
  #     sh -c "python -c 'from sqlalchemy import create_engine, text; import time; db_url = \"postgresql://user:password@db/restaurant_db\"; engine = create_engine(db_url); i=0; while i<30: try: with engine.connect() as connection: connection.execute(text(\"SELECT 1\")); print(\"Database ready!\"); break; except Exception as e: print(f\"Waiting for database... ({e})\"); time.sleep(2); i+=1; else: raise RuntimeError(\"Database not ready after 60 seconds\")' &&
  #              python your_main_saga_app_file.py"
  #   # Replace `your_main_saga_app_file.py` with the actual name of your Python script
  #   # For example: `python saga_app.py`
  #   # The `sh -c` command ensures the database is ready before running your app.
  #   # This `command` will run ALL your FastAPI apps (Choreography and Orchestration)
  #   # in one container as background threads, as per your Python script's `if __name__ == "__main__":` block.

# Docker Volumes for persistent data
volumes:
  pgdata:
  redisdata: